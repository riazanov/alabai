/* Copyright (C) 2010 Alexandre Riazanov (Alexander Ryazanov)
 *
 * The copyright owner licenses this file to You under the Apache License, 
 * Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package logic.is.power.alabai;


import java.util.*;

import logic.is.power.cushion.*;


/**
 * Common umbrella for all modules implementing clausification inferences
 * (eg, skolemisation) and deduction inferences (eg, resolution and 
 * paramodulation).
 */
class GeneratingInferenceCentre implements SimpleReceiver<FineSelectionUnit>
{

    /** @param resultAssembler where the clauses generated by various
     *         inferences will be assembled
     */
    public
	GeneratingInferenceCentre(NewClauseAssembler resultAssembler,
				  int maximalSelectionUnitPenalty) {

	_printPromotedUnits = false;

	_watchList = null;

	_selectionUnitPromotion = 
	    new SelectionUnitPromotion(maximalSelectionUnitPenalty);

	_selUnitBeingPromoted = new Ref<FineSelectionUnit>(); 

	_resolution = new Resolution(resultAssembler);

	_paramodulation = new Paramodulation(resultAssembler);

	_equalityResolution = new EqualityResolution(resultAssembler);

	_equalityFactoring = new EqualityFactoring(resultAssembler);
    }


    public void setCheckUnifierDirectionsInResolution(boolean fl) {
	_resolution.setCheckUnifierDirections(fl);
    }

    public void setCheckUnifierDirectionsInParamodulation(boolean fl) {
	_paramodulation.setCheckUnifierDirections(fl);
    }


    public void setPrintPromotedUnits(boolean flag) {
	_printPromotedUnits = flag;
    }

    /** Specifies promotions of which selection unit to report;
     *  make the parameter <code>null</code> if all units should be watched.
     */
    public void setWatchList(Set<Long> watchList) {
	_watchList = watchList;
    }

    
    /** Indicates that some inference operations are in progress
     *  that cannot be interrupted by calls to
     *  {@link #remove(FineSelectionUnit selUnit)}.
     */
    public boolean isBusy() {
	return _selUnitBeingPromoted.content != null;
    }


    /** Accomodates the specified selection unit in the internal
     *  database of units available for inferences.
     *  <b>pre:</b> isBusy() need not be false.
     *  @return <code>true</code> (always)
     */
    public boolean receive(FineSelectionUnit selUnit) {

	_selectionUnitPromotion.add(selUnit);

	return true;
    }

    /** Removes the selection unit from the internal database of 
     *  units available for inferences.
     *  <b>pre:</b> <code>isBusy() == false</code>.
     */
    public void remove(FineSelectionUnit selUnit) {

	assert !isBusy();

	_selectionUnitPromotion.remove(selUnit);
  
	switch (selUnit.kind())
	{
	    case FineSelectionUnit.Kind.ResolutionI: // as below
	    case FineSelectionUnit.Kind.ResolutionG: // as below
	    case FineSelectionUnit.Kind.ResolutionB: // as below
		_resolution.remove(selUnit);
		break;
	    case FineSelectionUnit.Kind.EqLHSForParamodI: // as below
	    case FineSelectionUnit.Kind.EqLHSForParamodG: // as below
	    case FineSelectionUnit.Kind.EqLHSForParamodB: // as below
	    case FineSelectionUnit.Kind.RedexForParamod:
		_paramodulation.remove(selUnit);
		break;
	    case FineSelectionUnit.Kind.EqualityFactoring:
		break;
	    case FineSelectionUnit.Kind.EqualityResolution:
		break;
      
	    default:
		assert false;
		break;
	}; // switch (selUnit.kind())

    } // remove(FineSelectionUnit selUnit)

    /** Tries to perform some work on realising some generating
     *  inferences, such as resolution or paramodulation.
     *  Occasionally checks 
     *  {@link cushion_je.SwitcheableAbortFlag#current()}.
     *  @return <code>false</code> if absolutely nothing can be done, even
     *          work that does not result in new clauses
     */
    public boolean doSomething()
	throws SwitcheableAbortFlag.Exception {

	SwitcheableAbortFlag.current().check();

	if (_selUnitBeingPromoted.content == null) 
	{
	    
	    if (!_selectionUnitPromotion.select(_selUnitBeingPromoted))
	    {
		assert _selUnitBeingPromoted.content == null;
		return false;
	    };

	    registerPromotion(_selUnitBeingPromoted.content);

	    // Promote the selection unit in the corresponding rule:
      
	    Ref<Boolean> lastPromotion = new Ref<Boolean>();

	    switch (_selUnitBeingPromoted.content.kind())
	    {
		case FineSelectionUnit.Kind.ResolutionI: // as below
		case FineSelectionUnit.Kind.ResolutionG: // as below
		case FineSelectionUnit.Kind.ResolutionB: 
		    _resolution.promote(_selUnitBeingPromoted.content,
					lastPromotion);
		    break;
		case FineSelectionUnit.Kind.EqLHSForParamodI: // as below
		case FineSelectionUnit.Kind.EqLHSForParamodG: // as below
		case FineSelectionUnit.Kind.EqLHSForParamodB: // as below
		case FineSelectionUnit.Kind.RedexForParamod:
		    _paramodulation.promote(_selUnitBeingPromoted.content,
					    lastPromotion);
		    break;
		case FineSelectionUnit.Kind.EqualityFactoring:
		    lastPromotion.content = true;
		    break;
		case FineSelectionUnit.Kind.EqualityResolution:
		    lastPromotion.content = true;
		    break;
	      
		default:
		    assert false;
		    break;
	    }; // switch (_selUnitBeingPromoted.kind())      

	  
	    if (lastPromotion.content)
		_selectionUnitPromotion.remove(_selUnitBeingPromoted.content);

	}; // if (_selUnitBeingPromoted.content == null) 

  
	SwitcheableAbortFlag.current().check();

	// Actually perform some inferences:

	switch (_selUnitBeingPromoted.content.kind())
	{
	    case FineSelectionUnit.Kind.ResolutionI: // as below
	    case FineSelectionUnit.Kind.ResolutionG: // as below
	    case FineSelectionUnit.Kind.ResolutionB: // as below
		if (!_resolution.performSomeInferences())
		{
		    _resolution.finishCurrentPromotion();
		    _selUnitBeingPromoted.content = null;
		};
		break;
	    case FineSelectionUnit.Kind.EqLHSForParamodI:
	    case FineSelectionUnit.Kind.EqLHSForParamodG:
	    case FineSelectionUnit.Kind.EqLHSForParamodB:
	    case FineSelectionUnit.Kind.RedexForParamod:
		if (!_paramodulation.performSomeInferences())
		{
		    _paramodulation.finishCurrentPromotion();
		    _selUnitBeingPromoted.content = null;
		};
		break;
	    case FineSelectionUnit.Kind.EqualityFactoring:
		_equalityFactoring.
		    performAllInferences(_selUnitBeingPromoted.
					 content.
					 clause());
		_selUnitBeingPromoted.content = null;
		// Note that this is likely to lead to loosing
		// the reference to the selection unit,
		// in which case it is garbage-collected.

		break;

	    case FineSelectionUnit.Kind.EqualityResolution:
		_equalityResolution.
		    performAllInferences(_selUnitBeingPromoted.
					 content.
					 clause());

		_selUnitBeingPromoted.content = null;
		// Note that this is likely to lead to loosing
		// the reference to the selection unit,
		// in which case it is garbage-collected.

		break;
	      
	    default:
		assert false;
		break;
	}; // switch (_selUnitBeingPromoted.content.kind())      

	return true;

    } // doSomething()



    //                     Private methods:

      
    private void registerPromotion(FineSelectionUnit selUnit) {

	if (_printPromotedUnits) 
	    if (_watchList == null || 
		_watchList.contains(new Long(selUnit.number())))
		    System.out.println("SelUn/Prom: " + selUnit);
	

	switch (selUnit.kind())
	{
	    case FineSelectionUnit.Kind.ResolutionI:
		++(Statistics.current().fineSelectionUnits.resolution.promoted);
		break;
	    case FineSelectionUnit.Kind.ResolutionG:
		++(Statistics.current().fineSelectionUnits.resolution.promoted);
		break;
	    case FineSelectionUnit.Kind.ResolutionB:
		++(Statistics.current().fineSelectionUnits.resolution.promoted);
		break;
	    case FineSelectionUnit.Kind.EqLHSForParamodI:
		++(Statistics.current().fineSelectionUnits.eqLHSForParamodulation.promoted);
		break;
	    case FineSelectionUnit.Kind.EqLHSForParamodG:
		++(Statistics.current().fineSelectionUnits.eqLHSForParamodulation.promoted);
		break;
	    case FineSelectionUnit.Kind.EqLHSForParamodB:
		++(Statistics.current().fineSelectionUnits.eqLHSForParamodulation.promoted);
		break;
	    case FineSelectionUnit.Kind.RedexForParamod:
		++(Statistics.current().fineSelectionUnits.redexForParamodulation.promoted);
		break;
	    case FineSelectionUnit.Kind.EqualityFactoring:
		++(Statistics.current().fineSelectionUnits.equalityFactoring.promoted);
		break;
	    case FineSelectionUnit.Kind.EqualityResolution:
		++(Statistics.current().fineSelectionUnits.equalityResolution.promoted);
		break;
	  
	    default:
		assert false;
		break;
	}; // switch (selUnit.kind())

    } // registerPromotion(FineSelectionUnit selUnit)




    //                      Data:

    private boolean _printPromotedUnits;

    /** If this is nonnull, only promotions of units with numbers
     *  from this set will be reported.
     */
    private Set<Long> _watchList;

    private SelectionUnitPromotion _selectionUnitPromotion;

    /** Must be contain <code>null</code> to indicate that 
     *  no unit is being promoted and that <code>this</code> is ready
     *  for a new promotion.
     */
    private Ref<FineSelectionUnit> _selUnitBeingPromoted;
      

    /** Performs resolution inferences. */
    private Resolution _resolution;

    /** Performs paramodulation inferences. */
    private Paramodulation _paramodulation;

    private EqualityResolution _equalityResolution;

    private EqualityFactoring _equalityFactoring;

}; // class GeneratingInferenceCentre
