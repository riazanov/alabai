/* Copyright (C) 2010 Alexandre Riazanov (Alexander Ryazanov)
 *
 * The copyright owner licenses this file to You under the Apache License, 
 * Version 2.0 (the "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package logic.is.power.alabai;


import java.util.TreeSet;

import logic.is.power.logic_warehouse.*;



/**
 * Implements generating clausification inferences.
 */
public class Clausifier {

    /** @param resultAssembler where the clauses generated by various
     *         clausification inferences will be assembled
     */
    public Clausifier(NewClauseAssembler resultAssembler) {
	_resultAssembler = resultAssembler;
    }


    /** If <code>cl</code> contains 
     *  <a href="{@docRoot}/../glossary.html#complex_literal">complex literals</a>,
     *  one of them is selected,
     *  and appropriate clausification inferences are applied
     *  to the literal; the resulting clauses are sent to
     *  the {@link alabai_je.NewClauseAssembler} specified on construction
     *  of this clausifier object.
     *  <b>pre:</b> not necessarily <code>cl.isForClausification()</code>. 
     */
    public void process(Clause cl) {


	Literal lit = selectLiteral(cl);
    
	if (lit != null)
	    {
		assert lit.isGeneral();
	    
		Formula form = lit.body();

		if (form.kind() == Term.Kind.ConnectiveApplication)
		    {
			Connective connective = 
			    ((ConnectiveApplication)form).connective();
	    
			switch (connective.id())
			    {
			    case Connective.Id.Not:
				processNegation(cl,lit);
				break;
			    case Connective.Id.And:
				applyConjunctionElimination(cl,lit);
				break;
			    case Connective.Id.Or:
				applyExplicitDisjunctionElimination(cl,lit);
				break;
			    case Connective.Id.Equivalent:
				applyEquivalenceElimination(cl,lit);
				break;
			    case Connective.Id.Implies:
				applyImplicationElimination(cl,lit);
				break;
			    case Connective.Id.ReverseImplies:
				applyReverseImplicationElimination(cl,lit);
				break;
			    case Connective.Id.NotEquivalent:
				applyNotEquivalentElimination(cl,lit);
				break;
			    case Connective.Id.NotOr:
				applyNotOrElimination(cl,lit);
				break;
			    case Connective.Id.NotAnd:
				applyNotAndElimination(cl,lit);
				break;

			    default:
				assert false;
			    }; // switch (connective.id())
	    
		    }
		else
		    {
			assert form.kind() == Term.Kind.QuantifierApplication;
			Quantifier quantifier =
			    ((QuantifierApplication)form).quantifier();
		
			if (quantifier.id() == Quantifier.Id.ForAll) 
			    {
				applyUnivesalQuantifierElimination(cl,lit);
			    }
			else
			    {
				assert quantifier.id() == Quantifier.Id.Exist;
		
				applySkolemisation(cl,lit);
			    };
		    };
	    }; // if (lit != null)
	
    } // process(Clause cl)


    //                     Private methods:

    /** Selects one complex literal in <code>cl</code>,
     *  to which clausification has to be applied; returns null 
     *  if there are no complex literals in the clause.
     */
    private Literal selectLiteral(Clause cl) {

	// THIS IS A TEMPORARY IMPLEMENTATION: IT SELECTS THE LITERAL
	// ARBITRARILY.
	
	for (Literal lit : cl.literals())
	    if (lit.isGeneral()) return lit;
	
	return null;
    }



    /** Applies one of the rules for negation to the literal;
     *  may produce 1 or 2 result clauses depending on the rule being used.
     *  <b>pre:</b> <code>lit.isGeneral()</code> and <code>lit.body()</code> must
     *  be an application of negation to some formula.
     */
    private void processNegation(Clause cl,Literal lit) {

	assert lit.body().kind() == Term.Kind.ConnectiveApplication;
    
	ConnectiveApplication body = (ConnectiveApplication)(lit.body());

	assert body.connective().id() == Connective.Id.Not;
    
	Term atom = body.atom();
    
	// Check the kind of the argument:

	assert atom.kind() != Term.Kind.AtomicFormula || 
	    ((AtomicFormula)atom).predicate().isBuiltInTrue() ||
	    ((AtomicFormula)atom).predicate().isBuiltInFalse();

	if (atom.kind() == Term.Kind.AtomicFormula)
	    {
		
		startAssemblingResult(cl,lit,InferenceType.NegatedTruthConstant);
		_resultAssembler.openLiteral();

		if (((AtomicFormula)atom).predicate().isBuiltInTrue())
		    {
			// ~$true --> $false
			_resultAssembler.pushPredicate(Signature.current().builtInFalse());
			

		    }
		else
		    {
			assert ((AtomicFormula)atom).predicate().isBuiltInFalse();
			// ~$false --> $true
			
			_resultAssembler.pushPredicate(Signature.current().builtInTrue());
			
		    };

		_resultAssembler.endOfLiteral();
		_resultAssembler.endOfClause();
		++(Statistics.current().clausificationInferences.negatedTruthConstantRewriting);
		
	    }	
	else if (atom.kind() == Term.Kind.ConnectiveApplication) 
	    {
		
		Connective connective = 
		    ((ConnectiveApplication)atom).connective();
		
		Term atomArgument = 
		    ((ConnectiveApplication)atom).argument();

		switch (connective.id())
		    {
		    case Connective.Id.Not:
			// Cancel double negation: ~(~p) --> p
			startAssemblingResult(cl,lit,InferenceType.DoubleNegationCancellation);
			_resultAssembler.pushLiteralWithRenaming(true,atomArgument);
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.doubleNegationCancellation);
			break;

		    case Connective.Id.And:
			// Distribute negation over conjunction:
			// ~(p & q) --> ~p, ~q.
			assert atomArgument.isPair();
			startAssemblingResult(cl,lit,InferenceType.NegatedConjunction);
			_resultAssembler.pushLiteralWithRenaming(false,
								 ((TermPair)atomArgument).first());
			_resultAssembler.pushLiteralWithRenaming(false,
								 ((TermPair)atomArgument).second());		      	
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
			break;

		    case Connective.Id.Or:
			// Distribute negation over disjunction:
			// ~(p | q) --> ~p & ~q.
			assert atomArgument.isPair();
			startAssemblingResult(cl,lit,InferenceType.NegatedDisjunction);
			_resultAssembler.openLiteral();
			// &
			_resultAssembler.pushConnective(Connective.getAnd());
			// ~p
			_resultAssembler.pushConnective(Connective.getNot());
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).first());
			// ~q
			_resultAssembler.pushConnective(Connective.getNot());
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).second());
			_resultAssembler.endOfLiteral();
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
			break;

		    case Connective.Id.Equivalent:
			// Distribute negation over equivalence:
			// ~(p <=> q) --> p & ~q, ~p & q
			assert atomArgument.isPair();
			startAssemblingResult(cl,lit,InferenceType.NegatedEquivalence);
			//                Literal p & ~q:
			_resultAssembler.openLiteral();
			// &
			_resultAssembler.pushConnective(Connective.getAnd());
			// p
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).first());
			// ~q
			_resultAssembler.pushConnective(Connective.getNot());
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).second());
			_resultAssembler.endOfLiteral();
			//                Literal ~p & q:

			_resultAssembler.openLiteral();
			// &
			_resultAssembler.pushConnective(Connective.getAnd());
			// ~p
			_resultAssembler.pushConnective(Connective.getNot());
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).first());
			// q
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).second());
			_resultAssembler.endOfLiteral();
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
			break;

		    case Connective.Id.Implies:
			// Distribute negation over implication:
			// ~(p => q) --> p & ~q
			assert atomArgument.isPair();
			startAssemblingResult(cl,lit,InferenceType.NegatedImplication);
			_resultAssembler.openLiteral();
			// &
			_resultAssembler.pushConnective(Connective.getAnd());
			// p
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).first());
			// ~q
			_resultAssembler.pushConnective(Connective.getNot());
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).second());
			_resultAssembler.endOfLiteral();
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
			break;

		    case Connective.Id.ReverseImplies:
			// Distribute negation over reverse implication:
			// ~(p <= q) --> ~p & q
			assert atomArgument.isPair();
			startAssemblingResult(cl,lit,InferenceType.NegatedReverseImplication);
			_resultAssembler.openLiteral();
			// &
			_resultAssembler.pushConnective(Connective.getAnd());
			// ~p
			_resultAssembler.pushConnective(Connective.getNot());
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).first());
			// q
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).second());
			_resultAssembler.endOfLiteral();
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
			break;

		    case Connective.Id.NotEquivalent:
			// Distribute negation over <~>:
			// ~(p <~> q) --> p <=> q
			assert atomArgument.isPair();
			startAssemblingResult(cl,lit,InferenceType.NegatedNotEquivalent);
			_resultAssembler.openLiteral();
			// &
			_resultAssembler.pushConnective(Connective.getEquivalent());
			// p
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).first());
			// q
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).second());
			_resultAssembler.endOfLiteral();
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
			break;

		    case Connective.Id.NotOr:
			// Distribute negation over ~|:
			// ~(p ~| q) --> p, q
			assert atomArgument.isPair();
			startAssemblingResult(cl,lit,InferenceType.NegatedNotOr);
			_resultAssembler.pushLiteralWithRenaming(true,
								 ((TermPair)atomArgument).first());
			_resultAssembler.pushLiteralWithRenaming(true,
								 ((TermPair)atomArgument).second());
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
			break;


		    case Connective.Id.NotAnd:
			// Distribute negation over ~&:
			// ~(p ~& q) --> p & q
			assert atomArgument.isPair();
			startAssemblingResult(cl,lit,InferenceType.NegatedNotAnd);
			_resultAssembler.openLiteral();
			// &
			_resultAssembler.pushConnective(Connective.getAnd());
			// p
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).first());
			// q
			_resultAssembler.pushTermWithRenaming(((TermPair)atomArgument).second());
			_resultAssembler.endOfLiteral();
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
			break;


		    default:
			assert false;
	    
		    }; // switch (connective.id())
	
	    }
	else // atom.kind() != Term.Kind.ConnectiveApplication
	    {
		assert atom.kind() == Term.Kind.QuantifierApplication;
		Quantifier quantifier = 
		    ((QuantifierApplication)atom).quantifier();
		Term atomArgument = 
		    ((QuantifierApplication)atom).abstraction();
		assert atomArgument.kind() == Term.Kind.AbstractionTerm;
		if (quantifier.id() == Quantifier.Id.ForAll) 
		    {
			// Distribute negation over ![X]:
			// ~(![X] p) --> ?[X](~p)
			startAssemblingResult(cl,lit,InferenceType.NegatedForAll);
			_resultAssembler.openLiteral();
			// ?[X]
			_resultAssembler.pushQuantifier(Quantifier.getExist());
			_resultAssembler.pushAbstractionVarWithRenaming(((AbstractionTerm)atomArgument).
									variable());
			// ~p
			_resultAssembler.pushConnective(Connective.getNot());
			_resultAssembler.pushTermWithRenaming(((AbstractionTerm)atomArgument).matrix());
			_resultAssembler.endOfLiteral();
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
	    
		    }
		else // quantifier.id() != Quantifier.Id.ForAll
		    {
			assert quantifier.id() == Quantifier.Id.Exist;
			// Distribute negation over ?[X]:
			// ~(?[X] p) --> ![X](~p)
			startAssemblingResult(cl,lit,InferenceType.NegatedExist);
			_resultAssembler.openLiteral();
			// ![X]
			_resultAssembler.pushQuantifier(Quantifier.getForAll());
			_resultAssembler.pushAbstractionVarWithRenaming(((AbstractionTerm)atomArgument).
									variable());
			// ~p
			_resultAssembler.pushConnective(Connective.getNot());
			_resultAssembler.pushTermWithRenaming(((AbstractionTerm)atomArgument).matrix());
			_resultAssembler.endOfLiteral();
			_resultAssembler.endOfClause();
			++(Statistics.current().clausificationInferences.negationDistribution);
		    }; // if (quantifier.id() == Quantifier.Id.ForAll)

	    }; // if (atom.kind() == Term.Kind.ConnectiveApplication)

    } // processNegation(Clause cl,Literal lit)






    private void applyConjunctionElimination(Clause cl,Literal lit) {

	assert lit.atom().kind() == Term.Kind.ConnectiveApplication;
    
	ConnectiveApplication atom = (ConnectiveApplication)(lit.atom());

	assert atom.connective().id() == Connective.Id.And;

	Term argument = atom.argument();
    
	assert argument.isPair();

	// Inference: p & q --> p; q
    

	//            First clause, with p:
	
	startAssemblingResult(cl,lit,InferenceType.ConjunctionElimination);

	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).first());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.conjunctionElimination);

	//            Second clause, with q:

	startAssemblingResult(cl,lit,InferenceType.ConjunctionElimination);

	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).second());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.conjunctionElimination);

    } // applyConjunctionElimination(Clause cl,Literal lit)






    private 
	void 
	applyExplicitDisjunctionElimination(Clause cl,Literal lit) {

	assert lit.atom().kind() == Term.Kind.ConnectiveApplication;
    
	ConnectiveApplication atom = (ConnectiveApplication)(lit.atom());

	assert atom.connective().id() == Connective.Id.Or;

	Term argument = atom.argument();
    
	assert argument.isPair();

	// Inference: p | q --> p, q
    
	startAssemblingResult(cl,lit,InferenceType.DisjunctionElimination);

	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).first());

	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).second());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.explicitDisjunctionElimination);
	

    } // applyExplicitDisjunctionElimination(Clause cl,Literal lit)



    private void applyEquivalenceElimination(Clause cl,Literal lit) {

	assert lit.atom().kind() == Term.Kind.ConnectiveApplication;
    
	ConnectiveApplication atom = (ConnectiveApplication)(lit.atom());

	assert atom.connective().id() == Connective.Id.Equivalent;

	Term argument = atom.argument();
    
	assert argument.isPair();

	// Inference: p <=> q --> ~p, q;  p, ~q
    

	//                     First clause, with ~p, q

	startAssemblingResult(cl,lit,InferenceType.EquivalenceElimination);
    
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).first());
	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).second());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.secondaryConnectiveElimination);




	//                     Second clause, with p, ~q


	startAssemblingResult(cl,lit,InferenceType.EquivalenceElimination);
    
	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).first());
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).second());
	
	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.secondaryConnectiveElimination);

    } // applyEquivalenceElimination(Clause cl,Literal lit)




    private void applyImplicationElimination(Clause cl,Literal lit) {

	assert lit.atom().kind() == Term.Kind.ConnectiveApplication;
    
	ConnectiveApplication atom = (ConnectiveApplication)(lit.atom());

	assert atom.connective().id() == Connective.Id.Implies;

	Term argument = atom.argument();
    
	assert argument.isPair();

	// Inference: p => q --> ~p, q
    

	startAssemblingResult(cl,lit,InferenceType.ImplicationElimination);
    
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).first());
	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).second());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.secondaryConnectiveElimination);

    } // applyImplicationElimination(Clause cl,Literal lit)




    private 
	void 
	applyReverseImplicationElimination(Clause cl,Literal lit) {

	assert lit.atom().kind() == Term.Kind.ConnectiveApplication;
    
	ConnectiveApplication atom = (ConnectiveApplication)(lit.atom());

	assert atom.connective().id() == Connective.Id.ReverseImplies;

	Term argument = atom.argument();
    
	assert argument.isPair();

	// Inference: p <= q --> p, ~q
    

	startAssemblingResult(cl,lit,InferenceType.ReverseImplicationElimination);
    
	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).first());
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).second());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.secondaryConnectiveElimination);

    } // applyReverseImplicationElimination(Clause cl,Literal lit)



    private void applyNotEquivalentElimination(Clause cl,Literal lit) {

	
	assert lit.atom().kind() == Term.Kind.ConnectiveApplication;
    
	ConnectiveApplication atom = (ConnectiveApplication)(lit.atom());

	assert atom.connective().id() == Connective.Id.NotEquivalent;

	Term argument = atom.argument();
    
	assert argument.isPair();

	// Inference: p <~> q --> p, q;  ~p, ~q
    

	//                     First clause, with p, q

	startAssemblingResult(cl,lit,InferenceType.NotEquivalentElimination);
    
	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).first());
	_resultAssembler.pushLiteralWithRenaming(true,((TermPair)argument).second());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.secondaryConnectiveElimination);




	//                     Second clause, with ~p, ~q


	startAssemblingResult(cl,lit,InferenceType.NotEquivalentElimination);
    
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).first());
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).second());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.secondaryConnectiveElimination);

	

    } // applyNotEquivalentElimination(Clause cl,Literal lit)




    private void applyNotOrElimination(Clause cl,Literal lit) {

	assert lit.atom().kind() == Term.Kind.ConnectiveApplication;
    
	ConnectiveApplication atom = (ConnectiveApplication)(lit.atom());

	assert atom.connective().id() == Connective.Id.NotOr;

	Term argument = atom.argument();
    
	assert argument.isPair();

	// Inference: p ~| q --> ~p;   ~q
    

	//                     First clause, with ~p:

	startAssemblingResult(cl,lit,InferenceType.NotOrElimination);
    
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).first());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.secondaryConnectiveElimination);


	//                     Second clause, with ~q:


	startAssemblingResult(cl,lit,InferenceType.NotOrElimination);
    
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).second());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.secondaryConnectiveElimination);

    } // applyNotOrElimination(Clause cl,Literal lit) 





    private void applyNotAndElimination(Clause cl,Literal lit) {


	assert lit.atom().kind() == Term.Kind.ConnectiveApplication;
    
	ConnectiveApplication atom = (ConnectiveApplication)(lit.atom());

	assert atom.connective().id() == Connective.Id.NotAnd;

	Term argument = atom.argument();
    
	assert argument.isPair();

	// Inference: p ~& q --> ~p, ~q
    


	startAssemblingResult(cl,lit,InferenceType.NotAndElimination);
    
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).first());
	_resultAssembler.pushLiteralWithRenaming(false,((TermPair)argument).second());

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.secondaryConnectiveElimination);

    } // applyNotAndElimination(Clause cl,Literal lit)






    private 
	void 
	applyUnivesalQuantifierElimination(Clause cl,Literal lit) {

	assert lit.atom().kind() == Term.Kind.QuantifierApplication;
    
	QuantifierApplication atom = (QuantifierApplication)(lit.atom());

	assert atom.quantifier().id() == Quantifier.Id.ForAll;

	Term argument = atom.abstraction();
    
	assert argument.kind() == Term.Kind.AbstractionTerm;

	// Inference: ![X] p --> p

	startAssemblingResult(cl,lit,InferenceType.ForAllElimination);
    
	
	Term matrix = ((AbstractionTerm)argument).matrix();
	
	while (matrix.isAbstraction())
	    {
		matrix = ((AbstractionTerm)matrix).matrix();
	    };

	_resultAssembler.pushLiteralWithRenaming(true,matrix);
    
	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.explicitUniversalQuantifierElimination);
    
    } // applyUnivesalQuantifierElimination(Clause cl,Literal lit)




    private void applySkolemisation(Clause cl,Literal lit) {
	
	assert lit.atom().kind() == Term.Kind.QuantifierApplication;
    
	QuantifierApplication atom = (QuantifierApplication)(lit.atom());

	assert atom.quantifier().id() == Quantifier.Id.Exist;

	Term argument = atom.abstraction();
    
	assert argument.kind() == Term.Kind.AbstractionTerm;

	// Inference: ?[X] p(X,Y) --> p(skf(Y),Y)
  
	// NOTE THAT OUR VERSIOON OF SKOLEMISATION TAKES INTO ACCOUNT
	// ONLY UNIVERSALLY QUANTIFIED VARIABLES THAT ACTUALLY OCCUR IN THE MATRIX.
    
	TreeSet<Variable> freeVariables = new TreeSet<Variable>();

	argument.collectFreeVariables(freeVariables); // Y

	int skolemSymbolArity = freeVariables.size();

	Variable varX = ((AbstractionTerm)argument).variable(); // X

	Term matrix = ((AbstractionTerm)argument).matrix();
  
  
	// Create the skolem symbol:

	Function skolemFunc = null;
	IndividualConstant skolemConst = null;
  
	if (skolemSymbolArity == 0) {
	    skolemConst = Signature.current().skolemConstant("alabai_skc");
	}
	else
	    skolemFunc = Signature.current().skolemFunction("alabai_skf",
							    skolemSymbolArity);

	startAssemblingResult(cl,lit,InferenceType.ExistElimination);


	_resultAssembler.openLiteral();  


	// Push p(skf(Y),Y) into _resultAssembler, symbol by symbol: 

	Term.LeanIterator iter = new Term.LeanIterator(matrix);
	
	do
	    {
		Term subterm = iter.next();
		switch (subterm.kind())
		    {
		    case Term.Kind.Variable: 
			if (((Variable)subterm) == varX)
			    {
				// Must be replaced with skf(Y)
				if (skolemSymbolArity == 0) 
				    {
					_resultAssembler.pushConstant(skolemConst);
				    }
				else
				    {
					_resultAssembler.pushFunction(skolemFunc);
					
					for (Variable var : freeVariables)
					    _resultAssembler.pushVariableWithRenaming(var);
				    };
			    }
			else
			    _resultAssembler.pushVariableWithRenaming((Variable)subterm);
			break;
			
		    case Term.Kind.CompoundTerm:
			_resultAssembler.pushFunction(((CompoundTerm)subterm).function());
			break;
			
			
		    case Term.Kind.IndividualConstant:
			_resultAssembler.pushConstant((IndividualConstant)subterm);
			break;
			
		    case Term.Kind.AtomicFormula:
			_resultAssembler.pushPredicate(((AtomicFormula)subterm).predicate());
			break;   
			
		    case Term.Kind.ConnectiveApplication:
			_resultAssembler.pushConnective(((ConnectiveApplication)subterm).connective());
			break;
			
		    case Term.Kind.QuantifierApplication:
			_resultAssembler.pushQuantifier(((QuantifierApplication)subterm).quantifier());
			break;
			
		    case Term.Kind.AbstractionTerm:
			if (((AbstractionTerm)subterm).variable() == varX)
			    {
				// We have a situation ?[X] | .. ![X] ... or
				// ?[X] | .. ?[X] ...
				// The inner quantifier takes priority, so we do not
				// replace X inside this term with the skolem term.
	
				_resultAssembler.pushTermWithRenaming(subterm);
				iter.skipSubtermRemainder();
			    }
			else			
			    _resultAssembler.
				pushAbstractionVarWithRenaming(((AbstractionTerm)subterm).variable());
			break;
			
		    case Term.Kind.TermPair:   
			assert false; 
			break; 
			
		    default:
			assert false; 
			break;
		    }; // switch (subterm.kind())
		
	    }
	while (iter.hasNext());

	_resultAssembler.endOfLiteral();

	_resultAssembler.endOfClause();

	++(Statistics.current().clausificationInferences.skolemisation);


    } // applySkolemisation(Clause cl,Literal lit)


    
    /** Opens a new result clause and copies all literals from <code>cl</code> 
     *  to it (modulo the main variable renaming associated with
     *  the result assembler), except the literal <code>litToExclude</code>.
     */
    private void startAssemblingResult(Clause cl,
				       Literal litToExclude,
				       int inferenceType) {
	assert inferenceType >= 0;
	assert inferenceType <= InferenceType.maxValue();

	_resultAssembler.openClause(inferenceType);

	_resultAssembler.addParent(cl);

	for (Literal lit : cl.literals())
	    if (lit != litToExclude)
		_resultAssembler.pushLiteralWithRenaming(lit);
	
    } // startAssemblingResult(Clause cl,Literal litToExclude)



    //                          Data:


    private NewClauseAssembler _resultAssembler;

}; // class Clausifier
